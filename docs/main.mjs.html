<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>main.mjs - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/pricemi115/homebridge-grumptech-netnanny" target="_blank" >GrumpTech</a></h2><h3>Modules</h3><ul><li><a href="module-NetNannyModule.html">NetNannyModule</a></li><li><a href="module-NetworkTargetModule.html">NetworkTargetModule</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-license.html">license</a></li><li><a href="tutorial-security.html">security</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">main.mjs</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @description Homebridge integration for Net Nanny
 * @copyright 2021
 * @author Mike Price &lt;dev.grumptech@gmail.com>
 * @module NetNannyModule
 * @requires debug
 * @see {@link https://github.com/debug-js/debug#readme}
 * @requires fs
 * @see {@link https://nodejs.org/dist/latest-v16.x/docs/api/fs.html#file-system}
 * @requires url
 * @see {@link https://nodejs.org/dist/latest-v16.x/docs/api/url.html}
 * @requires path
 * @see {@link https://nodejs.org/dist/latest-v16.x/docs/api/path.html}
 * @requires sqlite3
 * @see {@link https://github.com/TryGhost/node-sqlite3#readme}
 * @requires is
 * @see {@link https://github.com/enricomarino/is}
 */

/*
 * IMPORTANT NOTICE
 *
 * One thing you need to take care of is, that you never ever ever import anything directly from the "homebridge" module (or the "hap-nodejs" module).
 * The import block below may seem like we do exactly that, but actually those imports are only used for types and interfaces
 * and will disappear once the code is compiled to Javascript.
 * In fact you can check that by running `npm run build` and opening the compiled Javascript file in the `dist` folder.
 * You will notice that the file does not contain a `... = require("homebridge");` statement anywhere in the code.
 *
 * The contents of the import statement below MUST ONLY be used for type annotation or accessing things like CONST ENUMS,
 * which is a special case as they get replaced by the actual value and do not remain as a reference in the compiled code.
 * Meaning normal enums are bad, const enums can be used.
 *
 * You MUST NOT import anything else which remains as a reference in the code, as this will result in
 * a `... = require("homebridge");` to be compiled into the final Javascript code.
 * This typically leads to unexpected behavior at runtime, as in many cases it won't be able to find the module
 * or will import another instance of homebridge causing collisions.
 *
 * To mitigate this the {@link API | Homebridge API} exposes the whole suite of HAP-NodeJS inside the `hap` property
 * of the api object, which can be acquired for example in the initializer function. This reference can be stored
 * and used to access all exported variables and classes from HAP-NodeJS.
 */
/*
import {
    API,
    APIEvent,
    CharacteristicEventTypes,
    CharacteristicSetCallback,
    CharacteristicValue,
    DynamicPlatformPlugin,
    HAP,
    Logging,
    PlatformAccessory,
    PlatformAccessoryEvent,
    PlatformConfig,
  } from "homebridge";
*/

// Internal dependencies
/* eslint-disable indent */
import {NetworkTarget as _NetworkTarget,
        PEAK_TYPES as _TARGET_PEAK_TYPES,
        DATA_BUFFER_TYPES as _TARGET_DATA_BUFFER_TYPES,
        ALERT_BITMASK as _TARGET_ALERT_BITMASK,
        NETWORK_TARGET_EVENTS as _NETWORK_TARGET_EVENTS} from './networkTarget.mjs';
/* eslint-enable indent */

// External dependencies and imports.
import _debugModule from 'debug';
import {readFileSync as _readFileSync, writeFile as _writeFile, access as _access, mkdir as _mkdir, constants as _fsConstants} from 'node:fs';
import {fileURLToPath as _fileURLToPath} from 'node:url';
import {EOL as _EOL} from 'node:os';
import {join as _join, dirname as _dirname} from 'node:path';
import _sqlite3Module from 'sqlite3';
import _is from 'is';

/**
 * @description Absolute path to this script file.
 * @private
 */
const __filename = _fileURLToPath(import.meta.url);
/**
 * @description Absolute path to the folder of this script file.
 * @private
 */
const __dirname = _dirname(__filename);

/**
 * @private
 * @description Debugging function pointer for runtime related diagnostics.
 */
const _debug = _debugModule('homebridge');

/**
 * @description Reference to the SQLite API. Used for debugging.
 * @private
 */
const _sqlite3 = _sqlite3Module.verbose();

// Internal Constants
// History:
//      v1: Initial Release
//      v2: Latency and Jitter
/**
 * @description Accessory Version
 * v1: Initial Release,
 * v2: Latency and Jitter,
 * @private
 */
const ACCESSORY_VERSION = 2;

/**
 * @description Service identification information
 * @private
 */
const SERVICE_INFO = {
    /* eslint-disable key-spacing, max-len */
    POWER   : {uuid:`B3D9583F-2050-43B6-A179-9D453B494220`, name:`Ping Control`,    udst:`PingControl`},
    LATENCY : {uuid:`9B838A70-8F81-4B76-BED5-3729F8F34F33`, name:`Latency`,         udst:`PingLatency`, peak:_TARGET_PEAK_TYPES.LATENCY,    data_buffer:_TARGET_DATA_BUFFER_TYPES.LATENCY,  alert_mask: _TARGET_ALERT_BITMASK.LATENCY},
    JITTER  : {uuid:`67434B8C-F3CC-44EA-BBE9-15B4E7A2CEBF`, name:`Jitter`,          udst:`PingJitter`,  peak:_TARGET_PEAK_TYPES.JITTER,     data_buffer:_TARGET_DATA_BUFFER_TYPES.JITTER,   alert_mask: _TARGET_ALERT_BITMASK.JITTER},
    LOSS    : {uuid:`9093B0DE-078A-4B19-8081-2998B26A9017`, name:`Packet Loss`,     udst:`PacketLoss`,  peak:_TARGET_PEAK_TYPES.LOSS,       data_buffer:_TARGET_DATA_BUFFER_TYPES.LOSS,     alert_mask: _TARGET_ALERT_BITMASK.LOSS},
    /* eslint-enable key-spacing, max-len */
};

/**
 * @description Default time for exporting the database to a CSV file (once per day).
 * @private
 */
const DEFAULT_DB_EXPORT_TIME_MS = 86400000/* milliseconds */;

/**
 * @description Maximum number of records in the history tables.
 * @private
 */
const DEFAULT_MAX_HISTORY_RECORDS = 250000;

/**
 * @description Initial value for the cached last export time.
 * @private
 */
const INVALID_LAST_EXPORT_TIME = -1;

/**
 * @description Flag value for an invalid timeout
 * @private
 */
const INVALID_TIMEOUT_ID = -1;

/**
 * @description Package Information
 * @private
 */
let _PackageInfo;

/**
 * @description Homebridge API Version
 * @private
 */
let _HomebridgeAPIVersion;

/**
 * @description Homebridge Server Version
 * @private
 */
let _HomebridgeServerVersion;

/**
 * @description Platform accessory reference
 * @private
 */
let _PlatformAccessory  = undefined;
/**
 * @description Reference to the NodeJS Homekit Applicaiton Platform.
 * @private
 */
let _hap                = undefined;

/**
 * @description Root path for custom storage.
 * @private
 */
let _pathStorageRoot = '';

/**
 * @description Homebridge platform for managing the Net Nanny
 * @private
 */
class NetworkPerformanceMonitorPlatform {
    /**
     * @description Constructor
     * @param {object} log - Regerence to the log for logging in the Homebridge Context
     * @param {object} config - Reference to the platform configuration (from config.json)
     * @param {object} api - Reference to the Homebridge API
     * @throws {TypeError} - thrown if the configuration is invalid.
     * @private
     */
    constructor(log, config, api) {
        /* Cache the arguments. */
        this._log     = log;
        this._config  = config;
        this._api     = api;

        // Cached last export.
        this._lastExportTime = INVALID_LAST_EXPORT_TIME;

        // Flag indicating if an export is in progress.
        this._exportInProgres = false;

        /* My local data */
        this._name = this._config['name'];

        let theSettings = undefined;
        if (Object.prototype.hasOwnProperty.call(this._config, 'settings')) {
            // Get the system configuration,
            theSettings = this._config.settings;
        }

        // Reference to the "Refresh" accessory switch.
        this._switchRefresh = undefined;

        /* Bind Handlers */
        this._bindDoInitialization          = this._doInitialization.bind(this);
        this._bindPingReady                 = this._processPingReady.bind(this);
        this._bindDestructorNormal          = this._destructor.bind(this, {cleanup: true});
        this._bindDestructorAbnormal        = this._destructor.bind(this, {exit: true});
        this._bindExportDatabase            = this._on_export_database.bind(this);
        this._bindResetHistory              = this._handleResetDatabase.bind(this);

        /* Log our creation */
        this._log(`Creating NetworkPerformanceMonitorPlatform`);

        /* Create an empty map for our accessories */
        this._accessories = new Map();
        /* Create an empty map for our network performance targets. */
        this._networkPerformanceTargets = new Map();

        /* History Logging */
        this._enableHistoryLogging = true;
        this._historyLoggingPeriod = DEFAULT_DB_EXPORT_TIME_MS;
        this._maximumHistorySize   = DEFAULT_MAX_HISTORY_RECORDS;

        // Check for Settings
        if (theSettings != undefined) {
            /* Get the History Logging settings */
            /* Get history logging enabled */
            if ((Object.prototype.hasOwnProperty.call(theSettings, 'enable_history_logging')) &amp;&amp; (typeof(theSettings.enable_history_logging) === 'boolean')) {
                this._enableHistoryLogging = theSettings.enable_history_logging;
            }
            /* Get the history logging settings  */
            if ((Object.prototype.hasOwnProperty.call(theSettings, 'history_logging')) &amp;&amp; (typeof(theSettings.history_logging) === 'object')) {
                /* Get the history reporting period */
                if ((Object.prototype.hasOwnProperty.call(theSettings.history_logging, 'reporting_period')) &amp;&amp; (typeof(theSettings.history_logging.reporting_period) === 'number')) {
                    // The value from the settings is in days. Convert to milliseconds.
                    this._historyLoggingPeriod = (theSettings.history_logging.reporting_period * (24.0 * 3600000));
                }
                /* Get the maximum history reporting size */
                if ((Object.prototype.hasOwnProperty.call(theSettings.history_logging, 'maximum_history_size')) &amp;&amp; (typeof(theSettings.history_logging.maximum_history_size) === 'number')) {
                    this._maximumHistorySize = theSettings.history_logging.maximum_history_size;
                }
            }

            const commonTargetConfig = {};
            /* Get the ping count */
            if ((Object.prototype.hasOwnProperty.call(theSettings, 'ping_count')) &amp;&amp; (typeof(theSettings.ping_count) === 'number')) {
                commonTargetConfig.ping_count = theSettings.ping_count;
            }
            /* Get the packet size */
            if ((Object.prototype.hasOwnProperty.call(theSettings, 'packet_size')) &amp;&amp; (typeof(theSettings.packet_size) === 'number')) {
                commonTargetConfig.packet_size = theSettings.packet_size;
            }
            /* Get the ping period */
            if ((Object.prototype.hasOwnProperty.call(theSettings, 'ping_period')) &amp;&amp; (typeof(theSettings.ping_period) === 'number')) {
                commonTargetConfig.ping_period = theSettings.ping_period;
            }
            /* Get the ping interval */
            if ((Object.prototype.hasOwnProperty.call(theSettings, 'ping_interval')) &amp;&amp; (typeof(theSettings.ping_interval) === 'number')) {
                commonTargetConfig.ping_interval = theSettings.ping_interval;
            }

            /* Ping Target Specific configuration settings */
            if ((Object.prototype.hasOwnProperty.call(theSettings, 'ping_targets')) &amp;&amp; (Array.isArray(theSettings.ping_targets))) {
                for (const itemConfig of  theSettings.ping_targets) {
                    // Start with the common configs.
                    const targetConfig = commonTargetConfig;

                    if (typeof(itemConfig) === 'object') {
                        /* Get the Target Type */
                        if ((Object.prototype.hasOwnProperty.call(itemConfig, 'target_type')) &amp;&amp; (typeof(itemConfig.target_type) === 'string')) {
                            targetConfig.target_type = itemConfig.target_type;
                        }
                        /* Get the Target Destination */
                        if ((Object.prototype.hasOwnProperty.call(itemConfig, 'target_dest')) &amp;&amp; (typeof(itemConfig.target_dest) === 'string')) {
                            targetConfig.target_dest = itemConfig.target_dest;
                        }
                        /* Get the nominal ping latency */
                        if ((Object.prototype.hasOwnProperty.call(itemConfig, 'expected_latency')) &amp;&amp; (typeof(itemConfig.expected_latency) === 'number')) {
                            targetConfig.expected_latency = itemConfig.expected_latency;
                        }
                        /* Get the nominal ping stamdard deviation */
                        if ((Object.prototype.hasOwnProperty.call(itemConfig, 'expected_jitter')) &amp;&amp; (typeof(itemConfig.expected_jitter) === 'number')) {
                            targetConfig.expected_jitter = itemConfig.expected_jitter;
                        }
                        /* Get the packet loss limit */
                        if ((Object.prototype.hasOwnProperty.call(itemConfig, 'loss_limit')) &amp;&amp; (typeof(itemConfig.loss_limit) === 'number')) {
                            targetConfig.loss_limit = itemConfig.loss_limit;
                        }
                        /* Get the peak reset time (hr) */
                        if ((Object.prototype.hasOwnProperty.call(itemConfig, 'peak_expiration')) &amp;&amp; (typeof(itemConfig.peak_expiration) === 'number')) {
                            targetConfig.peak_expiration = itemConfig.peak_expiration;
                        }
                        /* Get the data filter time window (sec) */
                        if ((Object.prototype.hasOwnProperty.call(itemConfig, 'data_filter_time_window')) &amp;&amp; (typeof(itemConfig.data_filter_time_window) === 'number')) {
                            targetConfig.data_filter_time_window = itemConfig.data_filter_time_window;
                        }
                        /* Get the sensor alert mask */
                        if ((Object.prototype.hasOwnProperty.call(itemConfig, 'sensor_alert_mask')) &amp;&amp; (typeof(itemConfig.sensor_alert_mask) === 'number')) {
                            targetConfig.alert_mask = itemConfig.sensor_alert_mask;
                        }

                        /* Create the network target. */
                        const networkTarget = new _NetworkTarget(targetConfig);
                        this._networkPerformanceTargets.set(networkTarget.ID, networkTarget);
                    }
                }
            }
        }

        // Create an in-memory SQLite database for tracking performance history.
        this._db = undefined;
        if (this._enableHistoryLogging) {
            this._db = this._initializeHistoryDatabase();
        }

        // Timer for exporting the database.
        this._timeoutIDExportDB = INVALID_TIMEOUT_ID;

        // Register for the Did Finish Launching event
        this._api.on('didFinishLaunching', this._bindDoInitialization);
        this._api.on('shutdown', this._bindDestructorNormal);

        // Register for shutdown events.
        // do something when app is closing
        process.on('exit', this._bindDestructorNormal);
        // catches uncaught exceptions
        process.on('uncaughtException', this._bindDestructorAbnormal);
    }

    /**
     * @description Destructor
     * @param {object} options - Typically containing a "cleanup" or "exit" member.
     * @param {object} err - The source of the event trigger.
     * @returns {void}
     * @async
     * @private
     */
    async _destructor(options, err) {
        console.log(`Shutdown`);
        // Is there an indication that the system is either exiting or needs to
        // be cleaned up?
        if ((options.exit) || (options.cleanup)) {
            // Cleanup the network performance objects.
            clearTimeout(this._timeoutIDExportDB);
            this._db = null;
        }

        // Lastly eliminate myself.
        delete this;
    }

    /**
     * @description Event handler when the system has loaded the platform.
     * @returns {void}
     * @throws {TypeError} - thrown if the 'polling_interval' configuration item is not a number.
     * @throws {RangeError} - thrown if the 'polling_interval' configuration item is outside the allowed bounds.
     * @async
     * @private
     */
    async _doInitialization() {
        // Some network performance targets may still we waiting to complete initialization
        // (i.e. Gateways). Ensure that all npt's are not pending. If any are, then defer initialization.
        let defer = false;
        for (const target of this._networkPerformanceTargets.values()) {
            if (target.IsTargetSestinationPending) {
                // Give a bit
                this._log(`Target ${target.ID} is pending. Defer initialization..`);
                defer = true;
                // No need to continue looking.
                break;
            }
        }

        if (defer) {
            // Try again later.
            setTimeout(this._doInitialization.bind(this), 100);
        }
        else {
            this._log(`Homebridge Plug-In ${_PackageInfo.CONFIG_INFO.plugin} has finished launching.`);

            // Flush any accessories that are not from this version or are orphans (no corresponding network performance target).
            const accessoriesToRemove = [];
            for (const accessory of this._accessories.values()) {
                if (!Object.prototype.hasOwnProperty.call(accessory.context, 'VERSION') ||
                    (accessory.context.VERSION !== ACCESSORY_VERSION)) {
                    this._log(`Accessory ${accessory.displayName} has accessory version ${accessory.context.VERSION}. Version ${ACCESSORY_VERSION} is expected.`);
                    // This accessory needs to be replaced.
                    accessoriesToRemove.push(accessory);
                }
                else if (!this._networkPerformanceTargets.has(accessory.context.ID)) {
                    // Orphan accessory
                    this._log(`Accessory ${accessory.displayName} is an orphan and should be purged.`);
                    // This accessory needs to be replaced.
                    accessoriesToRemove.push(accessory);
                }
            }
            // Perform the cleanup.
            accessoriesToRemove.forEach((accessory) => {
                this._removeAccessory(accessory);
            });

            // Start the network performance targets
            for (const target of this._networkPerformanceTargets.values()) {
                // Is this network performance target new?
                if (!this._accessories.has(target.ID)) {
                    // There is no matching accessory for this network performance target.
                    // Create and register an accessory.
                    this._addNetworkPerformanceAccessory(target.ID);
                }

                // Register for the 'ready' event.
                target.on(_NETWORK_TARGET_EVENTS.EVENT_READY, this._bindPingReady);

                // Get the accessory to see if it is active or not.
                const accessory = this._accessories.get(target.ID);

                // Add this network target to the targets table.
                /* eslint-disable indent */
                this._db.run(`INSERT INTO targets(id, name, type) VALUES(?,?,?)`,
                             [target.ID, accessory.displayName, target.TargetType]);
                /* eslint-enable indent */

                // Is the accessory active?
                if (this._getAccessorySwitchState(accessory)) {
                    // Start the Network Performance Target.
                    // eslint-disable-next-line new-cap
                    target.Start();
                }
            }

            // If reporting is enabled, start the timer for the incremental database export.
            if (this._enableHistoryLogging) {
                this._timeoutIDExportDB = setTimeout(this._bindExportDatabase, this._historyLoggingPeriod, false);
            }
        }
    }

    /**
     * @description Event handler for the Ping Ready event
     * @param {object} results - Ping 'read' event results.
     * @param {_NetworkTarget} results.sender         - Reference to the sender of the event.
     * @param {boolean}        results.error          - Flag indicating is there is an error with the ping.
     * @param {number}         results.packet_loss    - Packet Loss (percent)
     * @param {number}         results.ping_latency_ms- Ping Latency in milliseconds.
     * @param {number}         results.ping_sjitter   - Ping Jitter in milliseconds.
     * @returns {void}
     * @throws {TypeError} - thrown if the 'results' is not an object having the expected values.
     * @throws {Error} - thrown if there is no accessory with a matching id as the sender.
     * @private
     */
    _processPingReady(results) {
        if ((results === undefined) || (typeof(results) !== 'object')                               ||
            (!Object.prototype.hasOwnProperty.call(results, 'sender')) || !(results.sender instanceof _NetworkTarget)      ||
            (!Object.prototype.hasOwnProperty.call(results, 'error')) || (typeof(results.error) !== 'boolean')             ||
            (!Object.prototype.hasOwnProperty.call(results, 'packet_loss')) || (typeof(results.packet_loss) !== 'number')  ||
            (!Object.prototype.hasOwnProperty.call(results, 'ping_latency_ms')) || (typeof(results.ping_latency_ms) !== 'number')||
            (!Object.prototype.hasOwnProperty.call(results, 'ping_jitter')) || (typeof(results.ping_jitter) !== 'number')      ) {
            const errText = (results === undefined) ? 'undefined' : results.toString();
            throw new TypeError(`Ping 'ready' results are invalid: ${errText}`);
        }

        this._log.debug(`Ping results: Target:${results.sender.TargetDestination} Error:${results.error} Loss:${results.packet_loss} Latency:${results.ping_latency_ms} Jitter:${results.ping_jitter}`);

        // Update the accessory with the data provided.
        // Get the id for the accessory
        const id = results.sender.ID;
        // Validate that an accessory exists for this id.
        if (this._accessories.has(id)) {
            const accessory = this._accessories.get(id);
            if (accessory !== undefined) {
                // Get the buffer filled flags.
                /* eslint-disable new-cap */
                const latencyBufferFilled   = results.sender.IsBufferFilled(SERVICE_INFO.LATENCY.data_buffer);
                const jitterBufferFilled     = results.sender.IsBufferFilled(SERVICE_INFO.JITTER.data_buffer);
                const lossBufferFilled      = results.sender.IsBufferFilled(SERVICE_INFO.LOSS.data_buffer);
                /* eslint-enable new-cap */

                // Compute the fault statuses
                const threshold     = (3.0*results.sender.ExpectedJitter);
                const latencyFault  = (results.error || (latencyBufferFilled  &amp;&amp; (results.ping_latency_ms > (results.sender.ExpectedJitter + threshold))));
                const jitterFault   = (results.error || (jitterBufferFilled &amp;&amp; (results.ping_jitter > results.sender.ExpectedJitter)));
                const lossFault     = ((lossBufferFilled &amp;&amp; (results.packet_loss > results.sender.TolerableLoss)) ? true : false);

                // Determine if the peaks have expired.
                /* eslint-disable new-cap */
                const resetPeakLatency  = results.sender.IsPeakExpired(SERVICE_INFO.LATENCY.peak);
                const resetPeakJitter   = results.sender.IsPeakExpired(SERVICE_INFO.JITTER.peak);
                const resetPeakLoss     = results.sender.IsPeakExpired(SERVICE_INFO.LOSS.peak);
                /* eslint-enable new-cap */


                // Update the values.
                this._updateCarbonDioxideSensorService(accessory,  SERVICE_INFO.LATENCY, {level: results.ping_latency_ms, fault: latencyFault, resetPeak: resetPeakLatency, active: true});
                this._updateCarbonDioxideSensorService(accessory,  SERVICE_INFO.JITTER,  {level: results.ping_jitter,     fault: jitterFault,  resetPeak: resetPeakJitter,  active: true});
                this._updateCarbonDioxideSensorService(accessory,  SERVICE_INFO.LOSS,    {level: results.packet_loss,     fault: lossFault,    resetPeak: resetPeakLoss,    active: true});

                // Log the data
                if (!_is.nil(this._db)) {
                    // Get the timestap for this record.
                    const timestamp = Date.now();

                    // Handle a possible rollover of the date.
                    if (timestamp &lt; this._lastExportTime) {
                        this._lastExportTime = timestamp;
                    }

                    this._db.serialize(()=> {
                        // Log the history entry.
                        const stmtHistory = this._db.prepare(`
                            INSERT INTO history(date, target_id, data_id)
                            VALUES('${timestamp}', '${id}', $dataKey);
                        `, (err) => {
                            if (_is.nil(err)) {
                                // Log the readings
                                this._db.run(`
                                    INSERT INTO data(latency_val, jitter_val, loss_val)
                                    VALUES('${results.ping_latency_ms}', '${results.ping_jitter}', '${results.packet_loss}');
                                `, [], function(err) {
                                    if (_is.nil(err)) {
                                        // Execute the history statement.
                                        // 'this' is valid here. Refers to the SQL Statement object.
                                        // eslint-disable-next-line no-invalid-this
                                        stmtHistory.run({$dataKey: this.lastID}, (err) => {
                                            if (!_is.nil(err)) {
                                                _debug(`Error executing history statement.`);
                                                _debug(err);
                                            }
                                        });
                                    }
                                    else {
                                        _debug(`Error with SQL Run`);
                                        _debug(err);
                                    }
                                });
                            }
                            else {
                                this._log.debug(`Error preparing the history table.`);
                                this._log.debug(err);
                            }
                        });
                    });
                }
            }
        }
        else {
            this._log.debug(`No accessory for sender ID: ${id}`);
            throw new Error(`No accessory for sender ID: ${id}`);
        }
    }

    /**
     * @description Homebridge API invoked after restoring cached accessorues from disk.
     * @param {_PlatformAccessory} accessory - Accessory to be configured.
     * @returns {void}
     * @throws {TypeError} - thrown if 'accessory' is not a PlatformAccessory
     * @private
     */
    configureAccessory(accessory) {
        // Validate the argument(s)
        if ((accessory === undefined) ||
            (!(accessory instanceof _PlatformAccessory))) {
            throw new TypeError(`accessory must be a PlatformAccessory`);
        }

        // Is this accessory already registered?
        let found = false;
        for (const acc of this._accessories.values()) {
            if (acc === accessory) {
                found = true;
                break;
            }
        }
        if (!found) {
            // Configure the accessory (also registers it.)
            try {
                this._configureAccessory(accessory);
            }
            catch (error) {
                this._log(`Unable to configure accessory ${accessory.displayName}. Version:${accessory.context.VERSION}. Error:${error}`);
                // We don't know where the exception happened. Ensure that the accessory is in the map.
                const id = accessory.context.ID;
                if (!this._accessories.has(id)) {
                    // Update our accessory listing
                    this._accessories.set(id, accessory);
                }
            }
        }
    }

    /**
     * @description Create and register an accessory for the network performance target.
     * @param {string} id identifier for the accessory.
     * @returns {void}
     * @throws {TypeError} - thrown when 'id' is not a string.
     * @throws {RangeError} - thrown when 'id' length is 0
     * @throws {Error} - thrown when an accessory with 'name' is already registered.
     * @throws {Error} - thrown when there is no matching network performance target.
     * @private
     */
    _addNetworkPerformanceAccessory(id) {
        // Validate arguments
        if ((id === undefined) || (typeof(id) !== 'string')) {
            throw new TypeError(`id must be a string`);
        }
        if (id.length &lt;= 0) {
            throw new RangeError(`id must be a non-zero length string.`);
        }
        if (this._accessories.has(id)) {
            throw new Error(`Accessory '${id}' is already registered.`);
        }
        if (!this._networkPerformanceTargets.has(id)) {
            throw new Error(`No Network Performance Target with id '${id}`);
        }

        // Get the network performance target with this 'id'.
        const target = this._networkPerformanceTargets.get(id);

        this._log.debug(`Adding new accessory: id:'${id}' target:${target.TargetDestination}`);

        // uuid must be generated from a unique but not changing data source, theName should not be used in the most cases. But works in this specific example.
        const uuid = _hap.uuid.generate(id);
        const accessory = new _PlatformAccessory(target.TargetDestination, uuid);

        // Add the identifier to the accessory's context. Used for remapping on depersistence.
        accessory.context.ID = id;
        // Mark the version of the accessory. This is used for depersistence
        accessory.context.VERSION = ACCESSORY_VERSION;
        // Create accessory persisted settings
        accessory.context.SETTINGS = {SwitchState: true};

        // Create our services.
        accessory.addService(_hap.Service.Switch,               SERVICE_INFO.POWER.uuid,   SERVICE_INFO.POWER.udst);
        accessory.addService(_hap.Service.CarbonDioxideSensor,  SERVICE_INFO.LATENCY.uuid, SERVICE_INFO.LATENCY.udst);
        accessory.addService(_hap.Service.CarbonDioxideSensor,  SERVICE_INFO.JITTER.uuid,  SERVICE_INFO.JITTER.udst);
        accessory.addService(_hap.Service.CarbonDioxideSensor,  SERVICE_INFO.LOSS.uuid,    SERVICE_INFO.LOSS.udst);

        try {
            // Configure the accessory
            this._configureAccessory(accessory);
        }
        catch (error) {
            this._log.debug(`Error when configuring accessory.`);
            this._log.debug(error);
        }

        this._api.registerPlatformAccessories(_PackageInfo.CONFIG_INFO.plugin, _PackageInfo.CONFIG_INFO.platform, [accessory]);
    }

    /**
     * @description Performs accessory configuration and internal 'registration' (appending to our list).
     *              Opportunity to setup event handlers for characteristics and update values (as needed).
     * @param {_PlatformAccessory} accessory - Accessory to be configured/registered
     * @returns {void}
     * @throws {TypeError} - thrown if 'accessory' is not a PlatformAccessory
     * @private
     */
    _configureAccessory(accessory) {
        if ((accessory === undefined) ||
            (!(accessory instanceof _PlatformAccessory))) {
            throw new TypeError(`accessory must be a PlatformAccessory`);
        }

        this._log.debug('Configuring accessory %s', accessory.displayName);

        // Get the accessory identifier from the contect.
        const id = accessory.context.ID;

        // Register to handle the Identify request for the accessory.
        accessory.on(_PlatformAccessory.PlatformAccessoryEvent.IDENTIFY, () => {
            this._log('%s identified!', accessory.displayName);
        });

        // Does this accessory have a Switch service?
        let switchState = true;
        const serviceSwitch = accessory.getService(_hap.Service.Switch);
        if ((serviceSwitch !== undefined) &amp;&amp;
            (serviceSwitch instanceof _hap.Service.Switch)) {
            // Set the switch to the stored setting (the default is on).
            const theSettings = accessory.context.SETTINGS;
            if ((theSettings !== undefined) &amp;&amp;
                (typeof(theSettings) === 'object') &amp;&amp;
                (Object.prototype.hasOwnProperty.call(theSettings, 'SwitchState') &amp;&amp;
                (typeof(theSettings.SwitchState) === 'boolean'))) {
                // Modify the settings
                switchState = theSettings.SwitchState;
            }
            serviceSwitch.updateCharacteristic(_hap.Characteristic.On, switchState);

            // Also update the name, so it is recognizable in the Home app
            serviceSwitch.updateCharacteristic(_hap.Characteristic.Name, `Power (${accessory.displayName})`);

            const charOn = serviceSwitch.getCharacteristic(_hap.Characteristic.On);
            // Register for the "get" event notification.
            charOn.on('get', this._handleOnGet.bind(this, id));
            // Register for the "set" event notification.
            charOn.on('set', this._handleOnSet.bind(this, id));
        }

        // Update the names of each service.
        const infoItems = [SERVICE_INFO.LATENCY, SERVICE_INFO.JITTER, SERVICE_INFO.LOSS];
        for (const item of infoItems) {
            const service = accessory.getServiceById(item.uuid, item.udst);
            if (service !== undefined) {
                service.updateCharacteristic(_hap.Characteristic.Name, `${item.name}-(${accessory.displayName})`);
            }
        }

        // Initialize the Carbon Dioxide Sensors
        this._updateCarbonDioxideSensorService(accessory, SERVICE_INFO.LATENCY, {level: 0.0, fault: false, resetPeak: true, active: switchState});
        this._updateCarbonDioxideSensorService(accessory, SERVICE_INFO.JITTER,  {level: 0.0, fault: false, resetPeak: true, active: switchState});
        this._updateCarbonDioxideSensorService(accessory, SERVICE_INFO.LOSS,    {level: 0.0, fault: false, resetPeak: true, active: switchState});

        // Update the accessory information
        this._updateAccessoryInfo(accessory, {model: 'GrumpTech Network Performance', serialnum: id});

        // Is this accessory new to us?
        if (!this._accessories.has(id)) {
            // Update our accessory listing
            this._log.debug(`Adding accessory '${accessory.displayName} to the accessories list. Count:${this._accessories.size}`);
            this._accessories.set(id, accessory);
        }
    }

    /**
     * @description Internal function to perform accessory configuration for Carbon Dioxide Sensor services.
     * @param {_PlatformAccessory} accessory - Accessory to be configured.
     * @param {object} serviceInfo - Name information of the service to be configured.
     * @param {string} serviceInfo.uuid   - UUID of the service
     * @param {string} serviceInfo.name   - Name of the service.
     * @param {string} serviceInfo.udst   - User Defined Sub-Type of the service.
     * @param {string} serviceInfo.peak   - Name of the 'peak'. Used to update the target when the peak is updated.
     * @param {string} serviceInfo.alert  - Name of the 'alert'. Used to update the target when a fault is set or cleared.
     * @param {object} values             - Object containing the values being set.
     * @param {number  | Error} values.level       - Value to be reported as the CO Level
     * @param {boolean | Error} values.fault       - true if a fault exists.
     * @param {boolean | Error} values.active      - specifies the low battery status
     * @param {boolean | Error} values.resetPeak   - true if the peak level should be reset.
     * @returns {void}
     * @throws {TypeError} - thrown if 'accessory' is not a PlatformAccessory
     * @throws {TypeError} - thrown if 'serviceInfo' does not conform to a serviceInfo item.
     * @throws {TypeError} - thrown if 'values' is not an object or does not contain the expected fields.
     * @throws {Error} - thrown if the service for the serviceName is not a Carbon Dioxide Sensor.
     * @private
     */
    _updateCarbonDioxideSensorService(accessory, serviceInfo, values) {
        if ((accessory === undefined) ||
            (!(accessory instanceof _PlatformAccessory))) {
            throw new TypeError(`accessory must be a PlatformAccessory`);
        }
        if ((serviceInfo === undefined) ||
            (typeof(serviceInfo) != 'object') ||
            (!Object.prototype.hasOwnProperty.call(serviceInfo, 'uuid')         || (typeof(serviceInfo.uuid)         !== 'string') || (serviceInfo.uuid.length &lt;= 0)        ) ||
            (!Object.prototype.hasOwnProperty.call(serviceInfo, 'name')         || (typeof(serviceInfo.name)         !== 'string') || (serviceInfo.name.length &lt;= 0)        ) ||
            (!Object.prototype.hasOwnProperty.call(serviceInfo, 'udst')         || (typeof(serviceInfo.udst)         !== 'string') || (serviceInfo.udst.length &lt;= 0)        ) ||
            (!Object.prototype.hasOwnProperty.call(serviceInfo, 'peak')         || (typeof(serviceInfo.peak)         !== 'string') || (serviceInfo.peak.length &lt;= 0)        ) ||
            (!Object.prototype.hasOwnProperty.call(serviceInfo, 'data_buffer')  || (typeof(serviceInfo.data_buffer)  !== 'string') || (serviceInfo.data_buffer.length &lt;= 0) ) ||
            (!Object.prototype.hasOwnProperty.call(serviceInfo, 'alert_mask')   || (typeof(serviceInfo.alert_mask)   !== 'number')                                          )   ) {
            throw new TypeError(`serviceName does not conform to a SERVICE_INFO item.`);
        }
        if ((values === undefined) || (typeof(values) !== 'object') ||
            (!Object.prototype.hasOwnProperty.call(values, 'level'))     || ((typeof(values.level) !== 'number')       || (values.level instanceof Error)) ||
            (!Object.prototype.hasOwnProperty.call(values, 'fault'))     || ((typeof(values.fault) !== 'boolean')      || (values.fault instanceof Error)) ||
            (!Object.prototype.hasOwnProperty.call(values, 'active'))    || ((typeof(values.active) !== 'boolean')     || (values.active instanceof Error)) ||
            (!Object.prototype.hasOwnProperty.call(values, 'resetPeak')) || ((typeof(values.resetPeak) !== 'boolean')  || (values.resetPeak instanceof Error)) ) {
            throw new TypeError(`values must be an object with properties named 'level' (number or Error) and 'fault' (boolean or Error) and 'resetPeak' (boolean or Error)`);
        }

        // Attempt to get the named service and validate that it is a Carbon Dioxie Sensor
        const serviceCO2Ping = accessory.getServiceById(serviceInfo.uuid, serviceInfo.udst);
        if ((serviceCO2Ping !== undefined) &amp;&amp;
            (serviceCO2Ping instanceof _hap.Service.CarbonDioxideSensor)) {
            try {
                // Get the network performance target for this accessory
                const target = this._networkPerformanceTargets.get(accessory.context.ID);

                // Determine the fault code and CO2 Level
                /* eslint-disable max-len */
                const faultCode = (values.fault                                                   ? _hap.Characteristic.StatusFault.GENERAL_FAULT                 : _hap.Characteristic.StatusFault.NO_FAULT);
                // eslint-disable-next-line new-cap
                const co2Level  = ((target.IsAlertActive(serviceInfo.alert_mask) &amp;&amp; values.fault) ? _hap.Characteristic.CarbonDioxideDetected.CO2_LEVELS_ABNORMAL : _hap.Characteristic.CarbonDioxideDetected.CO2_LEVELS_NORMAL);
                /* eslint-enable max-len */
                // Determine the low battery status based on being active or not.
                const batteryStatus = (values.active ? _hap.Characteristic.StatusLowBattery.BATTERY_LEVEL_NORMAL : _hap.Characteristic.StatusLowBattery.BATTERY_LEVEL_LOW);
                serviceCO2Ping.updateCharacteristic(_hap.Characteristic.CarbonDioxideDetected, co2Level);
                if (values.level >= 0.0) {
                    serviceCO2Ping.updateCharacteristic(_hap.Characteristic.CarbonDioxideLevel, values.level);
                }
                serviceCO2Ping.updateCharacteristic(_hap.Characteristic.StatusFault, faultCode);
                serviceCO2Ping.updateCharacteristic(_hap.Characteristic.StatusLowBattery, batteryStatus);
                serviceCO2Ping.updateCharacteristic(_hap.Characteristic.StatusActive, values.active);

                // Get the current peak.
                const currentPeak = serviceCO2Ping.getCharacteristic(_hap.Characteristic.CarbonDioxidePeakLevel).value;
                // Set the Peak Values if necessary,
                if ((values.resetPeak) ||
                    (values.level > currentPeak)) {
                    serviceCO2Ping.updateCharacteristic(_hap.Characteristic.CarbonDioxidePeakLevel, values.level);
                    // Update the peak time reference.
                    if (target !== undefined) {
                        // eslint-disable-next-line new-cap
                        target.UpdatePeakTime(serviceInfo.peak);
                    }
                }
            }
            catch (err) {
                this._log.debug(`Error setting characteristics for ${accessory.displayName}. Error: ${err}`);
            }
        }
        else {
            this._log.debug(`No service: Accessory ${accessory.displayName}`);
            throw new Error(`Accessory ${accessory.displayName} does not have a valid ${serviceInfo.uuid}:${serviceInfo.udst} service`);
        }
    }

    /**
     * @description Remove/destroy an accessory
     * @param {_PlatformAccessory} accessory - accessory to be removed.
     * @returns {void}
     * @throws {TypeError} - Thrown when 'accessory' is not an instance of _PlatformAccessory.
     * @throws {RangeError} - Thrown when a 'accessory' is not registered.
     * @private
     */
    _removeAccessory(accessory) {
        // Validate arguments
        if ((accessory === undefined) || !(accessory instanceof _PlatformAccessory)) {
            throw new TypeError(`Accessory must be a PlatformAccessory`);
        }
        if (!this._accessories.has(accessory.context.ID)) {
            throw new RangeError(`Accessory '${accessory.displayName}' is not registered.`);
        }

        this._log.debug(`Removing accessory '${accessory.displayName}'`);

        // Event Handler cleanup.
        accessory.removeAllListeners(_PlatformAccessory.PlatformAccessoryEvent.IDENTIFY);
        // Does this accessory have a Switch service?
        const serviceSwitch = accessory.getService(_hap.Service.Switch);
        if (serviceSwitch !== undefined) {
            const charOn = serviceSwitch.getCharacteristic(_hap.Characteristic.On);
            // Register for the "get" event notification.
            charOn.off('get', this._handleOnGet.bind(this, accessory));
            // Register for the "get" event notification.
            charOn.off('set', this._handleOnSet.bind(this, accessory));
        }

        /* Unregister the accessory */
        this._api.unregisterPlatformAccessories(_PackageInfo.CONFIG_INFO.plugin, _PackageInfo.CONFIG_INFO.platform, [accessory]);
        /* remove the accessory from our mapping */
        this._accessories.delete(accessory.context.ID);
    }

    /**
     * @description Update common information for an accessory
     * @param {_PlatformAccessory} accessory - accessory to be updated.
     * @param {object} info - accessory information.
     * @param {string | Error} info.model - accessory model number
     * @param {string | Error} info.serialnum - accessory serial number.
     * @returns {void}
     * @throws {TypeError} - Thrown when 'accessory' is not an instance of _PlatformAccessory.
     * @throws {TypeError} - Thrown when 'info' is not undefined, does not have the 'model' or
     *                       'serialnum' properties or the properties are not of the expected type.
     * @private
     */
    _updateAccessoryInfo(accessory, info) {
        // Validate arguments
        if ((accessory === undefined) || !(accessory instanceof _PlatformAccessory)) {
            throw new TypeError(`Accessory must be a PlatformAccessory`);
        }
        if ((info === undefined) ||
            (!Object.prototype.hasOwnProperty.call(info, 'model'))     || ((typeof(info.model)      !== 'string') || (info.model instanceof Error)) ||
            (!Object.prototype.hasOwnProperty.call(info, 'serialnum')) || ((typeof(info.serialnum)  !== 'string') || (info.serialnum instanceof Error))   ) {
            throw new TypeError(`info must be an object with properties named 'model' and 'serialnum' that are eother strings or Error`);
        }

        /* Get the accessory info service. */
        const accessoryInfoService = accessory.getService(_hap.Service.AccessoryInformation);
        if (accessoryInfoService != undefined) {
            /* Manufacturer */
            accessoryInfoService.updateCharacteristic(_hap.Characteristic.Manufacturer, `GrumpTech`);

            /* Model */
            accessoryInfoService.updateCharacteristic(_hap.Characteristic.Model, info.model);

            /* Serial Number */
            accessoryInfoService.updateCharacteristic(_hap.Characteristic.SerialNumber, info.serialnum);

            /* Software Version */
            accessoryInfoService.updateCharacteristic(_hap.Characteristic.SoftwareRevision, `v${accessory.context.VERSION}`);
        }
    }

    /**
     * @description Event handler for the "get" event for the Switch.On characteristic.
     * @param {string} id - accessory and id of the switch service being querried.
     * @param {Function} callback - Function callback for homebridge.
     * @returns {void}
     * @throws {TypeError} - thrown when 'id' is not a non-zero string.
     * @throws {Error} - Thrown when there is no accessory keyed with 'id'
     * @private
     */
    _handleOnGet(id, callback) {
        // Validate arguments
        if ((id === undefined) ||
            (typeof(id) !== 'string') || (id.length &lt;= 0)) {
            throw new TypeError(`id must be a non-zero length string.`);
        }

        let status = null;
        let result = new Error('not handled');
        if (this._accessories.has(id)) {
            // Get the accessory for this id.
            const accessory = this._accessories.get(id);

            // Get the accessory for this id.
            this._log.debug(`Ping Power '${accessory.displayName}' Get Request.`);

            try {
                result = this._getAccessorySwitchState(accessory);
            }
            catch (err) {
                this._log.debug(`  Unexpected error encountered: ${err.message}`);
                result = false;
                status = new Error(`Accessory ${accessory.displayName} is not ressponding.`);
            }
        }
        else {
            throw new Error(`id:${id} has no matching accessory`);
        }

        // Invoke the callback function with our result.
        callback(status, result);
    }

    /**
     * @description Event handler for the "set" event for the Switch.On characteristic.
     * @param {string} id - accessory and id of the switch service being querried.
     * @param {boolean} value - new/rewuested state of the switch
     * @param {Function} callback - Function callback for homebridge.
     * @returns {void}
     * @throws {TypeError} - thrown when 'id' is not a non-zero string.
     * @throws {Error} - Thrown when there is no accessory keyed with 'id'
     * @private
     */
    _handleOnSet(id, value, callback) {
        // Validate arguments
        if ((id === undefined) ||
            (typeof(id) !== 'string') || (id.length &lt;= 0)) {
            throw new TypeError(`id must be a non-zero length string.`);
        }

        let status = null;
        if (this._accessories.has(id)) {
            const accessory = this._accessories.get(id);
            this._log.debug(`Ping Power '${accessory.displayName}' Set Request. New state:${value}`);

            // Store the state of the switch so that when the plugin is restarted, we will restore the
            // switch state as it was last set.
            const theSettings = accessory.context.SETTINGS;
            if ((theSettings !== undefined) &amp;&amp;
                (typeof(theSettings) === 'object') &amp;&amp;
                (Object.prototype.hasOwnProperty.call(theSettings, 'SwitchState')) &amp;&amp;
                (typeof(theSettings.SwitchState) === 'boolean')) {
                // Modify the settings
                theSettings.SwitchState = value;
            }
            // Store the updated settings.
            accessory.context.SETTINGS = theSettings;

            try {
                // Is there a matching network performance target for this 'id'?
                if (this._networkPerformanceTargets.has(id)) {
                    const target = this._networkPerformanceTargets.get(id);
                    if (target !== undefined) {
                        // Update/reinitialize the accessory data (including the peak, as needed)
                        const theLevel = (value ? 0.0 : -1.0);
                        this._updateCarbonDioxideSensorService(accessory,  SERVICE_INFO.LATENCY, {level: theLevel, fault: false, resetPeak: value, active: value});
                        this._updateCarbonDioxideSensorService(accessory,  SERVICE_INFO.JITTER,  {level: theLevel, fault: false, resetPeak: value, active: value});
                        this._updateCarbonDioxideSensorService(accessory,  SERVICE_INFO.LOSS,    {level: theLevel, fault: false, resetPeak: value, active: value});

                        /* eslint-disable new-cap */
                        if (value) {
                            // Turn the Ping Power On !!
                            target.Start();
                        }
                        else {
                            // Note: Even after turning the ping power off, there may be one more result coming in.
                            target.Stop();
                        }
                        /* eslint-enable new-cap */
                    }
                }
                else {
                    throw new Error(`id:${id} has no matching network performance target.`);
                }
            }
            catch (err) {
                this._log.debug(`  Unexpected error encountered: ${err.message}`);

                status = new Error(`Accessory ${accessory.displayName} is not ressponding.`);
            }
        }
        else {
            throw new Error(`id:${id} has no matching accessory`);
        }

        callback(status);
    }

    /**
     * @description Event handler for the "set" event for the Switch.On characteristic of the database reset.
     * @param {boolean} value - new/rewuested state of the switch
     * @param {Function} callback - Function callback for homebridge.
     * @returns {void}
     * @private
     */
    _handleResetDatabase(value, callback) {
        this._log.debug(`Reset Database New state:${value}`);

        if (this._enableHistoryLogging) {
            if (_is.boolean(value)) {
                // Ensure that an export is not currently in progress.
                if (!this._exportInProgres) {
                    if (value) {
                        // Stop the existing export timer.
                        clearTimeout(this._timeoutIDExportDB);

                        // Reset the cashed last export time so that all exting gata will be exported.
                        this._lastExportTime = INVALID_LAST_EXPORT_TIME;

                        // Immediately queue an export.
                        this._timeoutIDExportDB = setImmediate(this._bindExportDatabase, true);
                    }

                    callback(null);
                }
                else if (value) {
                    // Export is in progress. Defer the request to reset the history.
                    this._log.debug(`Defering history reset.`);
                    setImmediate(this._bindResetHistory, value, callback);
                }
            }
            else {
                callback(new TypeError(`valie is invalid.`));
            }
        }
        else {
            // Logging not active.
            callback(null);
        }
    }

    /**
     * @description Get the value of the Service.Switch.On characteristic value
     * @param {object} accessory - accessory being querried.
     * @returns {boolean} the value of the On characteristic (true or false)
     * @throws {TypeError} - TThrown when 'accessory' is not an instance of _PlatformAccessory.
     * @throws {Error}  - Thrown when the On characteristic cannot be found on the accessory.
     * @private
     */
    _getAccessorySwitchState(accessory) {
        // Validate arguments
        if ((accessory === undefined) || !(accessory instanceof _PlatformAccessory)) {
            throw new TypeError(`Accessory must be a PlatformAccessory`);
        }

        let result = false;
        const serviceSwitch = accessory.getService(_hap.Service.Switch);
        if (serviceSwitch !== undefined) {
            const charOn = serviceSwitch.getCharacteristic(_hap.Characteristic.On);
            if (charOn !== undefined) {
                result = charOn.value;
            }
            else {
                throw new Error(`The Switch service of accessory ${accessory.displayName} does not have an On charactristic.`);
            }
        }
        else {
            throw new Error(`Accessory ${accessory.displayName} does not have a Switch service.`);
        }

        return result;
    }

    /**
     * @description Helper to initialize the in-memory SQL database for recording historical network performance data.
     * @returns {void}
     * @private
     */
    _initializeHistoryDatabase() {
        let theDB = undefined;

        if (this._enableHistoryLogging) {
            theDB = new _sqlite3.Database(':memory:');
            // Initialize the database
            theDB.serialize(()=> {
                // Activate foreigh key support
                theDB.exec(`
                    PRAGMA foreign_keys = ON;
                `, (err) => {
                    if (!_is.nil(err)) {
                        this._log.debug(`Error enabling foreigh keys.`);
                        this._log.debug(err);
                    }
                });
                // Create a table for general appliction info.
                theDB.exec(`
                    CREATE TABLE info (
                                        plugin_version            TEXT    NOT NULL,
                                        homebridge_api_version    TEXT    NOT NULL,
                                        homebridge_server_version TEXT    NOT NULL,
                                        hap_library_version       TEXT    NOT NULL,
                                        accessory_version         INTEGER NOT NULL DEFAULT 0
                    );
                    CREATE TABLE targets(
                                        id   TEXT    NOT NULL PRIMARY KEY DEFAULT 0,
                                        name TEXT    NOT NULL,
                                        type INTEGER NOT NULL DEFAULT 0
                    );
                `, (err) => {
                    if (!_is.nil(err)) {
                        this._log.debug(`Error creating info table.`);
                        this._log.debug(err);
                    }
                });
                // Populate the info table
                /* eslint-disable new-cap */
                theDB.exec(`
                    INSERT INTO info(plugin_version, homebridge_api_version, homebridge_server_version, hap_library_version, accessory_version)
                    VALUES('${_PackageInfo.PLUGIN_VER}', '${_HomebridgeAPIVersion}', '${_HomebridgeServerVersion}', '${_hap.HAPLibraryVersion()}', ${ACCESSORY_VERSION});
                `, (err) => {
                    this._log.debug(`Error populating the info table.`);
                    this._log.debug(err);
                });
                /* eslint-enable new-cap */
            });
            // Create the history tables.
            this._initializeHistoryTables(theDB);
        }

        return theDB;
    }

    /**
     * @description Helper to create/re-create the tables used to record the historical network performance data.
     * @param {_sqlite3.Database} theDB - reference to the database.
     * @returns  {void}
     * @private
     */
    _initializeHistoryTables(theDB) {
        if (_is.defined(theDB) &amp;&amp;
            _is.instance(theDB, _sqlite3.Database)) {
            theDB.serialize(() => {
                // Delete the tables if they exist.
                theDB.exec(`
                    DROP TABLE IF EXISTS history;
                    DROP TABLE IF EXISTS data;
                `, (err) => {
                    if (!_is.nil(err)) {
                        this._log.debug(`Unable to clear history tables.`);
                        this._log.debug(err);
                    }
                });

                // Create the table structure.
                theDB.exec(`
                    CREATE TABLE data(
                        id          INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL DEFAULT 0,
                        latency_val INTEGER NOT NULL DEFAULT 0,
                        jitter_val  INTEGER NOT NULL DEFAULT 0,
                        loss_val    INTEGER NOT NULL DEFAULT 0
                    );
                    CREATE TABLE history(
                        id          INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL DEFAULT 0,
                        date        INTEGER                           NOT NULL DEFAULT 0,
                        target_id   TEXT                              NOT NULL,
                        data_id     INTEGER                           NOT NULL DEFAULT 0,
                        FOREIGN KEY (target_id) REFERENCES targets(id) ON DELETE CASCADE ON UPDATE NO ACTION,
                        FOREIGN KEY (data_id)   REFERENCES data(id)    ON DELETE CASCADE ON UPDATE NO ACTION
                    );
                `, (err) => {
                    if (_is.nil(err)) {
                        // Reset the cached export reference
                        this._lastExportTime = INVALID_LAST_EXPORT_TIME;
                    }
                    else {
                        this._log.debug(`Error creating history tables.`);
                        this._log.debug(err);
                    }
                });
            });
        }
        else {
            this._log.debug(`Invalid database.`);
        }
    }

    /**
     * @description Helper to maintaiin a reasonable amount of data in the history tables.
     * @param {number} recordLimit - Maximum number of rows for the data tables.
     * @returns {void}
     * @private
     */
    _trimHistoryTables(recordLimit) {
        if (_is.integer(recordLimit) &amp;&amp; _is.gt(recordLimit, 0) &amp;&amp;
            !_is.nil(this._db)) {
            // Get the number of rows in the 'data' table.
            this._db.get(`SELECT count(*) AS total FROM data;`, (err, result) => {
                if (_is.nil(err) &amp;&amp; _is.integer(result.total)) {
                    // Determine if we have exceeded the size limitation
                    if (result.total > recordLimit) {
                        // Compute the number of rows to be trimmed and add a 2% buffer.
                        const trimSize =  Math.ceil((result.total - recordLimit) * 1.02);

                        this._db.serialize(() => {
                            // Trim the oldest rows
                            this._db.exec(`
                                DELETE FROM data
                                WHERE id IN (SELECT id from data LIMIT ${trimSize});
                            `, (err) => {
                                if (!_is.nil(err)) {
                                    this._log.debug(`Error trimming data`);
                                    this._log.debug(err);
                                }
                            });
                            // Sanity: Make sure that the history table was updated as well
                            this._db.get(`SELECT count(*) AS totalHistory FROM history;`, (err, result) => {
                                if (result.totalHistory !== recordLimit) {
                                    throw Error(`History table is out of sync. Rows=${result.totalHistory} Expected=${recordLimit}`);
                                }
                            });
                        });
                    }
                }
                else {
                    this._log.debug(`Error gettng number of data records.`);
                    this._log.debug(err);
                }
            });
        }
    }

    /**
     * @description Event handler for the timer indicating that a dataexport is needed.
     * @param {boolean} flushHistory - Flag indicating that the history data should be reset.
     * @returns {void}
     * @throws {TypeError} - thrown if 'resetDB' is not a boolean.
     * @private
     */
    async _on_export_database(flushHistory) {
        if (!_is.boolean(flushHistory)) {
            throw new TypeError(`'flushHistory' must be a boolean.`);
        }

        if (this._enableHistoryLogging) {
            // Get the current timestamp
            const timestamp = new Date(Date.now());

            let errorEncountered = false;
            this._exportInProgres = true;

            // Build the path for the log file.
            const fileName = _join(_pathStorageRoot, `History_${timestamp.getTime()}.csv`);

            this._log.debug(`Exporting database: ${fileName}`);
            let historyContent = '';
            this._db.serialize(() => {
                // Get the header information.
                this._db.get(`SELECT * FROM info`, (err, result) => {
                    if (_is.nil(err)) {
                        // Append 'info' header
                        historyContent += `timestamp:,${timestamp.toDateString()} @ ${timestamp.toTimeString()}${_EOL}`;
                        historyContent += `plugin version:,${result.plugin_version}${_EOL}`;
                        historyContent += `homebridge api version:,${result.homebridge_api_version}${_EOL}`;
                        historyContent += `homebridge server version:,${result.homebridge_server_version}${_EOL}`;
                        historyContent += `hap library version:,${result.hap_library_version}${_EOL}`;
                        historyContent += `node.js version:,${process.versions.node}${_EOL}`;
                        historyContent += `accessory version:,${result.accessory_version}${_EOL}`;
                        historyContent += _EOL;
                    }
                    else {
                        this._log.debug(`Error getting info table.`);
                        this._log.debug(err);
                        errorEncountered = true;
                        this._exportInProgres = false;
                    }
                });

                // Collect the history data.
                if (!errorEncountered) {
                    this._db.all(`
                                SElECT
                                    date, t.name AS target_name, t.type AS target_type, d.latency_val AS latency, d.jitter_val AS jitter, d.loss_val AS loss
                                    FROM history h
                                INNER JOIN targets t
                                    ON t.id = target_id
                                INNER JOIN data d
                                    ON d.id = data_id
                                WHERE
                                    date > ${this._lastExportTime}
                                ORDER BY
                                    date;
                        `, (err, rows) => {
                        if (_is.nil(err)) {
                            // Ensure there is data to be logged.
                            if (rows.length > 0) {
                                // Append the 'history' header
                                historyContent += `date,name,type,latency (ms),jitter (ms),loss${_EOL}`;

                                // Append the history data.
                                rows.forEach((row) => {
                                    // Get the date of the record
                                    const theDate = new Date(row.date);
                                    // Append the data
                                    // eslint-disable-next-line max-len
                                    historyContent += `${theDate.toDateString()} @ ${theDate.toTimeString()},${row.target_name},${row.target_type},${row.latency},${row.jitter},${row.loss}${_EOL}`;
                                });

                                // Write the file.
                                _writeFile(fileName, historyContent, (err) => {
                                    if (!_is.nil(err)) {
                                        this._log.debug(`Error exporting history:`);
                                        this._log.debug(err);
                                    }
                                });

                                // Update the timestamp of the most recent record exported.
                                this._lastExportTime = rows[rows.length - 1].date;

                                // The export is complete.
                                this._exportInProgres = false;
                            }
                            else {
                                this._log.debug(`No history data`);
                                this._log.debug(rows);

                                // The export is complete.
                                this._exportInProgres = false;
                            }
                        }
                        else {
                            this._log.debug(`Error accessing history`);
                            this._log.debug(err);

                            // The export is complete.
                            this._exportInProgres = false;
                        }
                    });
                }

                // Ensure the database does not grow too large, unless we will be dumping the database anyway.
                if (!flushHistory) {
                    this._trimHistoryTables(this._maximumHistorySize);
                }
            });

            // If requested, flush the history from the database.
            if (flushHistory) {
                this._initializeHistoryTables(this._db);
            }

            // Restart the timer for an incremental export.
            this._timeoutIDExportDB = setTimeout(this._bindExportDatabase, this._historyLoggingPeriod, false);
        }
    }
}

/**
 * @description Helper to get the information of interest from the package.json file.
 * @returns {object} Data of interest.
 * @private
 */
function _getPackageInfo() {
    const packageFilename = _join(__dirname, '../package.json');
    const rawContents = _readFileSync(packageFilename);
    const parsedData = JSON.parse(rawContents);

    const pkgInfo = {CONFIG_INFO: parsedData.config_info, PLUGIN_VER: parsedData.version};

    return pkgInfo;
}

/**
 * @description Exported default function for Homebridge integration.
 * @param {object} homebridgeAPI - reference to the Homebridge API.
 * @returns {void}
 */
export default (homebridgeAPI) => {
    // Cache the homebridge API and Server versions
    _HomebridgeAPIVersion = homebridgeAPI.version;
    _HomebridgeServerVersion = homebridgeAPI.serverVersion;
    _debug(`homebridge API version: v${_HomebridgeAPIVersion}`);
    _debug(`homebridge Server version: v${_HomebridgeServerVersion}`);

    // Get the package information.
    _PackageInfo = _getPackageInfo();

    // Compute and cache the storage path.
    _pathStorageRoot = _join(homebridgeAPI.user.customStoragePath, _PackageInfo.CONFIG_INFO.platform);
    // Check access to the storage location.
    _access(_pathStorageRoot, _fsConstants.F_OK, (err) => {
        // Create the storage folder if it does not exist.
        if (!_is.nil(err)) {
            _mkdir(_pathStorageRoot, (err) => {
                if (!_is.nil(err)) {
                    _debug(`Unable to create plugin storage folder.`);
                    _debug(err);
                }
            });
        }
    });

    // Accessory must be created from PlatformAccessory Constructor
    _PlatformAccessory  = homebridgeAPI.platformAccessory;
    if (!Object.prototype.hasOwnProperty.call(_PlatformAccessory, 'PlatformAccessoryEvent')) {
        // Append the PlatformAccessoryEvent.IDENTITY enum to the platform accessory reference.
        // This allows us to not need to import anything from 'homebridge'.
        const platformAccessoryEvent = {
            IDENTIFY: 'identify',
        };

        _PlatformAccessory.PlatformAccessoryEvent = platformAccessoryEvent;
    }

    // Cache the reference to hap-nodejs
    _hap = homebridgeAPI.hap;

    // Register the paltform.
    _debug(`Registering platform: ${_PackageInfo.CONFIG_INFO.platform}`);
    homebridgeAPI.registerPlatform(_PackageInfo.CONFIG_INFO.platform, NetworkPerformanceMonitorPlatform);
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
